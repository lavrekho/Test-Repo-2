#define TRACE_LIFECYCLE
#define TRACE_INTERNALS_CHANGES
#define TRACE_EXCEPTIONS_AND_CURIOSITY

//#define TRACE_PLUGIN_CALLBACK_CALLS_WITH_PROCESS_NAME


using System;
using System.Diagnostics;
using System.Reflection;
using System.Net;
using System.Xml;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;
using System.Management;
using System.Text.RegularExpressions;
using System.Globalization;
using System.IO.Compression;
using System.Threading;

using OneBrowse;


namespace MailChecker
{
    public class MailChecker : FilterPlugin
    {
        #region Constants

        const string OVERRIDE_INI_CONTENT =

@"Opera Preferences version 2.1
; Do not edit this file while Opera is running
; This file is stored in UTF-8 encoding

[127.0.0.1]
Network|Allow Cross Network Navigation=1

[Overrides]
127.0.0.1";

        #endregion

        #region Class Level Variables 
        
        #region Request Headers

        private static Regex _requestUriPattern =
            new Regex("^get ([^ ]+) http/",
                RegexOptions.IgnoreCase);

        private static Regex _hostPattern =
            new Regex("host: ?([^\r]+)",
                RegexOptions.IgnoreCase);

        private static Regex _rgAcceptEncoding =
            new Regex("(?<ae>Accept-Encoding: )(.*?)(?<crlf>\r\n)",
                RegexOptions.IgnoreCase);

        private static Regex _rgTE =
            new Regex("(?<te>TE: )(.*?)(?<crlf>\r\n)",
                RegexOptions.IgnoreCase);

        #endregion

        #region Response Headers

        // "Content-Type: text/html; charset=UTF-8; dir=RTL"
        private static Regex _rgContentType =
            new Regex("Content-Type: (?<type>.*?)/(?<subtype>[^;\r\n]*)(;\\s*?charset=(?<charset>[^;\r\n]*))?(.*?)\r\n",
                RegexOptions.IgnoreCase);

        private static Regex _rgContentTypeHttpEquiv =
            new Regex("http-equiv=[\",\']*content-type[\",\']*\\s*?content=[\",\']*(?<type>.*?)/(?<subtype>.*?);\\s*?charset=(?<charset>[^\",\']+)*",
                RegexOptions.IgnoreCase);

        private static Regex _rgContentLength =
            new Regex("(?<cl>Content-Length: )(?<length>.*?)(?<crlf>\r\n)",
                RegexOptions.IgnoreCase);

        private static Regex _rgContentEncoding =
            new Regex("Content-Encoding: (?<ce>.*?)\r\n",
                RegexOptions.IgnoreCase);

        private static Regex _rgTransferEncoding =
            new Regex("Transfer-Encoding: (?<te>.*?)\r\n",
                RegexOptions.IgnoreCase);

        private static Regex _bodyTagPattern =
            new Regex("(<body[^>]*?>)",
                RegexOptions.IgnoreCase);

        #endregion

        private AccountsMonitor _monitor;

        private string _popupIFrame;

        private Thread _thFixOperaBrowser;

        #endregion

        #region Constructors / Destructors

        public MailChecker() : base()
        {
#if TRACE_LIFECYCLE
            Debug.WriteLine("MailChecker(), version: " + PluginVersion.ToString());
#endif
            _monitor = new AccountsMonitor();

            _httpModule = new MailCheckerHttpModule(this);

            _processesToCapture = new PluginProcessList(this);


            _popupIFrame = ((MailCheckerHttpModule)_httpModule).PopupIFrame;

            Enable += new EventHandler<EventArgs>(MailChecker_Enable);
            Disable += new EventHandler<EventArgs>(MailChecker_Disable);

            _thFixOperaBrowser = new Thread(new ThreadStart(FixOperaBrowser))
            {
                IsBackground = true
            };
        }

        private void MailChecker_Enable(object sender, EventArgs e)
        {
            _monitor.StartAccountsMonitoring();    
        }

        private void MailChecker_Disable(object sender, EventArgs e)
        {
            _monitor.StopAccountsMonitoring();
        }

        ~MailChecker()
        {
#if TRACE_LIFECYCLE
            Debug.WriteLine("~MailChecker(), version: " + PluginVersion.ToString());
#endif
            try
            {
                _thFixOperaBrowser.Abort();
            }
            catch { }
        }

        #endregion

        #region Properties
        
        internal AccountsMonitor Monitor
        {
            get
            {
                return _monitor;
            }
        } 
        
        #endregion

        #region Methods (Private)

        private void KillOperaBrowserProcess()
        {
            // kill "opera.exe" process
            foreach (Process proc in Process.GetProcesses())
            {
                if (proc.ProcessName.ToLower() != "opera")
                    continue;

                try
                {
                    proc.Kill();
                }
                catch { }
            }
        }

        private void FixOperaBrowser()
        {
            /* get Application Directory path for SYSTEM account */

            string appDataFolder = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

#if TRACE_INTERNALS_CHANGES
            Debug.Print("MailChecker.FixOperaBrowser() : Env.GetFolderPath(Env.SpecialFolder.ApplicationData) = " + appDataFolder);
#endif
            /* get the name of logged user */

            ManagementObjectSearcher searcher;

            searcher = new ManagementObjectSearcher("SELECT UserName FROM Win32_ComputerSystem");
            ManagementObjectCollection collection = searcher.Get();

            if (collection.Count != 1)
                return;

            ManagementBaseObject[] objects = new ManagementBaseObject[collection.Count];
            collection.CopyTo(objects, 0);

            string loggedUsername = (string)objects[0]["UserName"];

            int index = loggedUsername.IndexOf('\\');

            if (index >= 0)
                loggedUsername = loggedUsername.Substring(index + 1);

#if TRACE_INTERNALS_CHANGES
            Debug.Print("MailChecker.FixOperaBrowser() : username = " + loggedUsername);
#endif
            /* get OS version */

            Version osVersion = Environment.OSVersion.Version;

            if (Environment.OSVersion.Platform == PlatformID.Win32NT)
            {
                // XP
                if (osVersion.Major == 5 && (osVersion.Minor == 1 || osVersion.Minor == 2))
                {
                    appDataFolder = appDataFolder.Replace("LocalService", loggedUsername).Replace("Default User", loggedUsername);
                }
                // Vista, Windows 7, Windows 8
                else if (osVersion.Major == 6 && (osVersion.Minor >= 0 && osVersion.Minor <= 2))
                {
                    appDataFolder = appDataFolder.Replace("\\Windows\\system32\\config\\systemprofile\\", "\\Users\\{0}\\");

                    appDataFolder = string.Format(appDataFolder, loggedUsername);
                }
                else
                    return;
            }
            else
                return;


            /* get Application Directory path for Opera browser for logges user account */

            string operaAppDataFolder = Path.Combine(Path.Combine(appDataFolder, "Opera"), "Opera");

#if TRACE_INTERNALS_CHANGES
            Debug.Print("MailChecker.FixOperaBrowser() : Opera application folder = " + operaAppDataFolder);
#endif

            /* check whether Opera installed */

            if (Directory.Exists(operaAppDataFolder))
            {
                // fix Opera's "override.ini" : modify if it exists OR create if doesn't exist yet

                string operaOverrideIniFile = Path.Combine(operaAppDataFolder, "override.ini");

                if (File.Exists(operaOverrideIniFile))
                {
                    // indicate whether we added our localhost rule to "override.ini"
                    bool @fixed = false;

                    string NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_1 = "Network|Allow Cross Network Navigation=1";
                    string NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_0 = "Network|Allow Cross Network Navigation=0";
                    string LOCALHOST_IP = "127.0.0.1";

                    List<string> lines = new List<string>(File.ReadAllLines(operaOverrideIniFile));

                    int stIndex = lines.IndexOf("[Overrides]");

                    if (stIndex >= 0)
                    {
                        int endIndex = lines.IndexOf(string.Empty, stIndex);

                        if (endIndex == -1)
                            endIndex = lines.Count - 1;

                        int ipIndex = lines.IndexOf(LOCALHOST_IP, stIndex);

                        if (ipIndex > stIndex && ipIndex <= endIndex)
                        {
                            ipIndex = lines.IndexOf("[127.0.0.1]");

                            if (ipIndex >= 0)
                            {
                                int offInd = lines.IndexOf(NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_0, ipIndex);
                                int onInd = lines.IndexOf(NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_1, ipIndex);
                                int emptyInd = lines.IndexOf(string.Empty, ipIndex);

                                if (offInd > 0 && offInd < emptyInd)
                                {
                                    @fixed = true;

                                    lines[offInd] = NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_1;
                                }
                                else
                                {
                                    if (onInd > 0)
                                    {
                                        if (onInd > emptyInd)
                                        {
                                            @fixed = true;

                                            lines.Insert(ipIndex + 1, NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_1);
                                        }
                                    }
                                    else
                                    {
                                        @fixed = true;

                                        lines.Insert(ipIndex + 1, NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_1);
                                    }
                                }
                            }
                            else
                            {
                                @fixed = true;

                                ipIndex = -1;
                            }
                        }
                        else
                        {
                            @fixed = true;

                            lines.Insert(stIndex + 1, LOCALHOST_IP);

                            ipIndex = lines.IndexOf("[127.0.0.1]");

                            if (ipIndex >= 0)
                            {
                                int offInd = lines.IndexOf(NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_0, ipIndex);
                                int onInd = lines.IndexOf(NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_1, ipIndex);
                                int emptyInd = lines.IndexOf(string.Empty, ipIndex);

                                if (offInd > 0 && offInd < emptyInd)
                                {
                                    lines[offInd] = NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_1;
                                }
                                else
                                {
                                    if (onInd > 0)
                                    {
                                        if (onInd > emptyInd)
                                        {
                                            @fixed = true;

                                            lines.Insert(ipIndex + 1, NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_1);
                                        }
                                    }
                                    else
                                    {
                                        @fixed = true;

                                        lines.Insert(ipIndex + 1, NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_1);
                                    }
                                }
                            }
                            else
                                ipIndex = -1;
                        }

                        if (ipIndex == -1)
                        {
                            lines.Add(string.Empty);
                            lines.Add("[127.0.0.1]");
                            lines.Add(NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_1);
                        }
                    }
                    else
                    {
                        @fixed = true;

                        lines.Add(string.Empty);
                        lines.Add("[127.0.0.1]");
                        lines.Add(NETWORK_ALLOW_CROSS_NETWORK_NAVIGATION_1);

                        lines.Add(string.Empty);
                        lines.Add("[Overrides]");
                        lines.Add(LOCALHOST_IP);
                    }

                    if (@fixed)
                    {
                        // kill "opera.exe"
                        KillOperaBrowserProcess();

                        // write back MODIFIED content
                        File.WriteAllLines(operaOverrideIniFile, lines.ToArray());
#if TRACE_INTERNALS_CHANGES
                        Debug.Print("MailChecker.FixOperaBrowser() : update 'override.ini' for EXISTING installation @ " + operaOverrideIniFile);
#endif
                    }
                    else
                    {
#if TRACE_INTERNALS_CHANGES
                        Debug.Print("MailChecker.FixOperaBrowser() : NO update required for 'override.ini' for EXISTING installation @ " + operaOverrideIniFile);
#endif
                    }
                }
                else
                {
#if TRACE_INTERNALS_CHANGES
                    Debug.Print("MailChecker.FixOperaBrowser() : update 'override.ini' for EXISTING installation @ " + operaOverrideIniFile);
#endif
                    // kill "opera.exe"
                    KillOperaBrowserProcess();

                    // create "override.ini" file
                    File.WriteAllText(operaOverrideIniFile, OVERRIDE_INI_CONTENT, Encoding.UTF8);
                }
            }


            /* start folder watching on Environment.SpecialFolder.ApplicationData for "Opera/Opera" */
            FileSystemWatcher _appDataFolderWatcher = new FileSystemWatcher(appDataFolder)
            {
                NotifyFilter = NotifyFilters.DirectoryName,
                EnableRaisingEvents = true,
                Filter = "*.*",
                IncludeSubdirectories = true
            };

            _appDataFolderWatcher.Created += new FileSystemEventHandler(_appDataFolderWatcher_Created);
        }

        private void _appDataFolderWatcher_Created(object sender, FileSystemEventArgs e)
        {
            if (e.ChangeType != WatcherChangeTypes.Created)
                return;

            if (e.Name.ToLower() == "opera\\opera")
            {
                //  e.FullPath will be:

                // XP          -> \Documents and Settings\{user name}\Application Data\Opera\Opera\
                // Vista, 7, 8 -> \Users\{user name}\AppData\Roaming\Opera\Opera\

                string operaOverrideIniFile = Path.Combine(e.FullPath, "override.ini");

#if TRACE_INTERNALS_CHANGES
                Debug.Print("MailChecker._appDataFolderWatcher_Created() : write 'override.ini' for NEW installation @ " + operaOverrideIniFile);
#endif
                // create "override.ini" file
                File.WriteAllText(operaOverrideIniFile, OVERRIDE_INI_CONTENT, Encoding.UTF8);
            }
        }

        private void LoadAccounts()
        {
            try
            {
                string curDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);

                using (FileStream fs = new FileStream(Path.Combine(curDir, "accounts.dat"), FileMode.Open))
                {
                    BinaryFormatter binFormatter = new BinaryFormatter()
                    {
                        Binder = new DeserializationBinder()
                    };

                    _monitor.Accounts = (List<MailAccount>)binFormatter.Deserialize(fs);
                }
            }
            catch (Exception)
            {
            }
        }

        private void SaveAccounts()
        {
            try
            {
                string curDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);

                using (FileStream fs = new FileStream(Path.Combine(curDir, "accounts.dat"), FileMode.Create))
                {
                    BinaryFormatter binFormatter = new BinaryFormatter();

                    binFormatter.Serialize(fs, _monitor.Accounts);
                }
            }
            catch
            {
            }
        }

        #endregion

        #region FilterPlugin members

        protected override void connectedHandler(object sender, ConnectedEventArgs e)
        {
            if (!_processesToCapture.ProcessEvent(e.Connection))
                return;

#if TRACE_PLUGIN_CALLBACK_CALLS_WITH_PROCESS_NAME

            Debug.WriteLine(string.Format("MailChecker() ({0}) : connectingHandler() : to {1} by '{2}'",
                PluginVersion.ToString(),
                e.Connection.RemoteEndPoint.ToString(),
                e.Connection.ProcessName));
#endif
        }

        protected override void sendStartedHandler(object sender, TransferringStartedEventArgs e)
        {
            e.DoAction = TcpFilterActions.PassThrough;

            if (!_processesToCapture.ProcessEvent(e.Connection))
                return;

#if TRACE_PLUGIN_CALLBACK_CALLS_WITH_PROCESS_NAME

            Debug.WriteLine(string.Format("MailChecker() ({0}) : sendStartedHandler() : to {1} by '{2}'",
                PluginVersion.ToString(),
                e.Connection.RemoteEndPoint.ToString(),
                e.Connection.ProcessName));
#endif
        }

        protected override void sendFinishedHandler(object sender, TransferringFinishedEventArgs e)
        {
            e.DoAction = TcpFilterActions.PassThrough;

            if (!_processesToCapture.ProcessEvent(e.Connection))
                return;

#if TRACE_PLUGIN_CALLBACK_CALLS_WITH_PROCESS_NAME

            Debug.WriteLine(string.Format("MailChecker() ({0}) : sendFinishedHandler() : to {1} by '{2}'",
                PluginVersion.ToString(),
                e.Connection.RemoteEndPoint.ToString(),
                e.Connection.ProcessName));
#endif
        }

        protected override void receiveStartedHandler(object sender, TransferringStartedEventArgs e)
        {
            e.DoAction = TcpFilterActions.PassThrough;

            if (!_processesToCapture.ProcessEvent(e.Connection))
                return;

#if TRACE_PLUGIN_CALLBACK_CALLS_WITH_PROCESS_NAME

            Debug.WriteLine(string.Format("MailChecker() ({0}) : receiveStartedHandler() : to {1} by '{2}'",
                PluginVersion.ToString(),
                e.Connection.RemoteEndPoint.ToString(),
                e.Connection.ProcessName));
#endif

            if (_monitor.NewMessagesCount == 0)
                return;

            if (e.LookupData.Length < 7)
            {
                e.DoAction = TcpFilterActions.CaptureSession;
                return;
            }

            string httpResponse = Encoding.ASCII.GetString(e.LookupData, 0, 7);

            e.DoAction = (httpResponse.StartsWith("http/1.", StringComparison.OrdinalIgnoreCase)) ? TcpFilterActions.CaptureSession : TcpFilterActions.PassThrough;
        }

        protected override void receiveFinishedHandler(object sender, TransferringFinishedEventArgs e)
        {
            e.DoAction = TcpFilterActions.PassThrough;

            if (!_processesToCapture.ProcessEvent(e.Connection))
                return;

#if TRACE_PLUGIN_CALLBACK_CALLS_WITH_PROCESS_NAME

            Debug.WriteLine(string.Format("MailChecker() ({0}) : receiveFinishedHandler() : to {1} by '{2}'",
                PluginVersion.ToString(),
                e.Connection.RemoteEndPoint.ToString(),
                e.Connection.ProcessName));
#endif
            if (e.LimitExceeded || e.SessionData.Length < 7 || _monitor.NewMessagesCount == 0)
                return;

            #region Filter responses

            // full HTTP response
            byte[] fullResponseBytes = e.SessionData.ToArray();

            string headers = Encoding.ASCII.GetString(fullResponseBytes);

            if (!headers.StartsWith("http/1.", StringComparison.OrdinalIgnoreCase))
                return;

            int bodySt = headers.IndexOf("\r\n\r\n") + 4;

            // headers and "\r\n\r\n" delimeter
            headers = headers.Substring(0, bodySt);


            Match ct = _rgContentType.Match(headers);

            if (!ct.Success) // unknown/missed mime
                return;

            string type = ct.Groups["type"].Value.ToLower();
            string subtype = ct.Groups["subtype"].Value.ToLower();
            string charset = ct.Groups["charset"].Value;

            if (type != "text" || subtype != "html")
                return;

            #endregion

            #region Assembly chunks

            Match mTransferEncoding = _rgTransferEncoding.Match(headers);

            if (mTransferEncoding.Success && mTransferEncoding.Groups["te"].Value.Trim() == "chunked")
            {
                if (e.LimitExceeded) // we can't assembly only part of the chunked response, so exit
                    return;

                MemoryStream chunked = new MemoryStream(fullResponseBytes, bodySt, fullResponseBytes.Length - bodySt);


                MemoryStream assembled = new MemoryStream();

                string chunkSizeStr;
                int chunkSize;
                int ch;
                bool parseResult;
                byte[] chunkBuffer;


                chunked.Position = 0;

                try
                {
                    do
                    {
                        chunkSizeStr = string.Empty;

                        do
                        {
                            ch = chunked.ReadByte();

                            if ((ch != '\r' && ch != -1))
                                chunkSizeStr += (char)ch;
                            else
                                break;
                        }
                        while (true);

                        ch = chunked.ReadByte(); // read '\n'

                        parseResult = Int32.TryParse(chunkSizeStr,
                             NumberStyles.HexNumber,
                             NumberFormatInfo.InvariantInfo,
                             out chunkSize);

                        if (!parseResult)
                            return;

                        if (chunkSize == 0)
                            break;

                        chunkBuffer = new byte[chunkSize < 2 ? 2 : chunkSize];

                        chunked.Read(chunkBuffer, 0, chunkSize);

                        assembled.Write(chunkBuffer, 0, chunkSize);

                        // read trailing "\r\n"
                        chunked.Read(chunkBuffer, 0, 2);
                    }
                    while (chunkSize > 0);

                }
                catch (Exception ex)
                {
#if TRACE_EXCEPTIONS_AND_CURIOSITY
                    Debug.WriteLine("MailChecker.receiveFinishedHandler() : chunks assembler : exception : " + ex.Message);
#endif
                    return;
                }

                // set pointer to body section
                e.SessionData.Position = bodySt;

                // overwrite chunked body with deassembled
                assembled.WriteTo(e.SessionData);

                // get back full HTTP response again (update fullResponseBytes)
                fullResponseBytes = e.SessionData.ToArray();
            }

            #endregion

            #region Decompress stream

            Match mContentEncoding = _rgContentEncoding.Match(headers);

            do
            {
                if (!mContentEncoding.Success)
                {
                    break;
                }

                string contentCoding = mContentEncoding.Groups["ce"].Value.Trim();

                if (contentCoding == "identity")
                {
                    break;
                }

                if (contentCoding != "gzip" && contentCoding != "deflate")
                    return;

                if (e.LimitExceeded) // we can't decompress only part of the response
                    return;

                // decompress body 

                MemoryStream compressed = new MemoryStream(fullResponseBytes, bodySt, fullResponseBytes.Length - bodySt);

                MemoryStream decompressed = new MemoryStream();


                byte[] buffer = new byte[4096];
                int readNum;


                try
                {
                    if (contentCoding == "gzip")
                    {
                        using (GZipStream decompressor = new GZipStream(compressed, CompressionMode.Decompress))
                        {
                            do
                            {
                                readNum = decompressor.Read(buffer, 0, buffer.Length);

                                decompressed.Write(buffer, 0, readNum);
                            }
                            while (readNum > 0);
                        }
                    }
                    else if (contentCoding == "deflate")
                    {
                        using (DeflateStream decompressor = new DeflateStream(compressed, CompressionMode.Decompress))
                        {
                            do
                            {
                                readNum = decompressor.Read(buffer, 0, buffer.Length);

                                decompressed.Write(buffer, 0, readNum);
                            }
                            while (readNum > 0);
                        }
                    }
                }
                catch (Exception ex)
                {
#if TRACE_EXCEPTIONS_AND_CURIOSITY
                    Debug.WriteLine("MailChecker.receiveFinishedHandler() : decompresssor : exception : " + ex.Message);
#endif
                    return;
                }

                // set pointer to body section
                e.SessionData.Position = bodySt;

                // overwrite compressed body with decompressed
                decompressed.WriteTo(e.SessionData);

                // update full HTTP response
                fullResponseBytes = e.SessionData.ToArray();
            }
            while (false);

            #endregion

            #region Convert bytes to string

            charset = ReValidateCharset(charset);

            bool charsetUnknown = (charset.Length == 0);

            if (charsetUnknown)
                charset = "utf-8"; // use UTF-8 as (a) default and (b) temporary charset

            Encoding encoding = Encoding.GetEncoding(charset);

            string body = encoding.GetString(fullResponseBytes, bodySt, (int)(fullResponseBytes.Length - bodySt));

            if (charsetUnknown) // in case of "Content-Type: type/subtype\r\n"
            {
                // search charset in the body
                ct = _rgContentTypeHttpEquiv.Match(body);

                if (ct.Success)
                {
                    charset = ct.Groups["charset"].Value;

                    if (charset.Length > 0)
                    {
                        charset = ReValidateCharset(charset);

                        encoding = Encoding.GetEncoding(charset);

                        body = encoding.GetString(fullResponseBytes, bodySt, (int)(fullResponseBytes.Length - bodySt));
                    }
                }
            }

            #endregion

            #region Modify string body

            if (_monitor.NewMessagesCount > 0)
            {
                body = _bodyTagPattern.Replace(body,
                    delegate(Match m)
                    {
                        return m.Value + _popupIFrame;
                    }, 1
                );

                //File.WriteAllText("c:\\injected_body_" + DateTime.Now.Millisecond.ToString() + ".txt", body);
            }

            #endregion

            #region Update headers and return back modified data

            e.SessionData = new MemoryStream();

            // (1) get body bytes
            byte[] bodyBytes = encoding.GetBytes(body);

            //File.WriteAllBytes("c:\\injected_body_" + DateTime.Now.Millisecond.ToString() + ".bin.txt", bodyBytes);

            /* remove encoding headers */
            headers = _rgContentEncoding.Replace(headers, string.Empty);
            headers = _rgTransferEncoding.Replace(headers, string.Empty);


            Match mContentLength = _rgContentLength.Match(headers);

            string contentLength;

            if (mContentLength.Success) // if Content-Length header exists
            {
                // update its value

                contentLength = "${cl}" + bodyBytes.Length.ToString() + "${crlf}";

                headers = _rgContentLength.Replace(headers, contentLength);
            }
            else
            {
                contentLength = string.Format("\r\nContent-Length: {0}", bodyBytes.Length);

                // remove "\r\n\r\n"
                headers = headers.Trim(new char[] { '\r', '\n' });

                headers += contentLength;

                headers += "\r\n\r\n";
            }

            // (2) get headers bytes
            byte[] headersBytes = Encoding.ASCII.GetBytes(headers);


            // (3) write headers 
            e.SessionData.Write(headersBytes, 0, headersBytes.Length);

            // (4) write body
            e.SessionData.Write(bodyBytes, 0, bodyBytes.Length);

            #endregion
        }

        protected override void disconnectedHandler(object sender, DisconnectedEventArgs e)
        {
            if (!_processesToCapture.ProcessEvent(e.Connection))
                return;

#if TRACE_PLUGIN_CALLBACK_CALLS_WITH_PROCESS_NAME

            Debug.WriteLine(string.Format("MailChecker() ({0}) : disconnectingHandler() : to {1} by '{2}'",
                PluginVersion.ToString(),
                e.Connection.RemoteEndPoint.ToString(),
                e.Connection.ProcessName));
#endif
        }

        public override Version PluginVersion
        {
            get
            {
                if (_pluginVersion == null)
                {
                    _pluginVersion = Assembly.GetExecutingAssembly().GetName().Version;
                }

                return _pluginVersion;
            }
        }

        #endregion

        #region IInitializable Members

        //<plugin enabled="True">
        //  <capture>
        //    <process>opera.exe</process>
        //    <process>firefoxportable.exe</process>
        //    <process>firefox.exe</process>
        //    <process>iexplore.exe</process>
        //    <process>chrome.exe</process>
        //  </capture>
        //</plugin>

        public override void Initialize(string settings)
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(settings);

            XmlNode xPlugin = xmlDoc.SelectSingleNode("plugin");

            _enabled = bool.Parse(xPlugin.Attributes["enabled"].Value);


            XmlNode xNode;


            /* parse processes to capture */
            xNode = xmlDoc.SelectSingleNode("plugin/capture");
            _processesToCapture.Initialize(xNode.OuterXml);

            
            // run Opera fix ("override.ini") thread
            _thFixOperaBrowser.Start();


            LoadAccounts();
        }

        public override string Preserve()
        {
            XmlDocument xmlDoc = new XmlDocument();

            XmlNode xPlugin = xmlDoc.AppendChild(xmlDoc.CreateElement("plugin"));
            xPlugin.Attributes.Append(xmlDoc.CreateAttribute("enabled")).Value = _enabled.ToString();


            /* save processes to capture */
            XmlDocument xProcesses = new XmlDocument();
            xProcesses.LoadXml(_processesToCapture.Preserve());
            xPlugin.AppendChild(xmlDoc.ImportNode(xProcesses.DocumentElement, true));


            // stop Opera fix thread 
            try
            {
                _thFixOperaBrowser.Abort();
            }
            catch { }


            SaveAccounts();
                      
            return xmlDoc.InnerXml;
        }

        #endregion

        #region Embedded Classes

        private class DeserializationBinder : SerializationBinder 
        {
            public override Type BindToType(string assemblyName, string typeName)
            {
                Type type = Type.GetType(string.Format("{0},{1}", typeName, assemblyName));

                if (type == null)
                {
#if TRACE_EXCEPTIONS_AND_CURIOSITY
                    Debug.WriteLine("MailChecker._DeserializationBinder.BindToType() : curiosity : 'type == null'");
#endif
                }

                return type;
            }
        }

        #endregion
    }
}